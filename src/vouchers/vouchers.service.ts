import { Injectable, Logger } from '@nestjs/common';
import { eventTypeToVoucherType } from 'src/common/interfaces/account';
import {
  IInvoiceWithPaymentMethod,
  isIInvoiceWithPaymentMethod,
} from 'src/common/interfaces/invoice';
import { ILineItem, cleanILineItem } from 'src/common/interfaces/line_item';
import { IVoucher, IVoucherMetaData } from 'src/common/interfaces/voucher';
import { ProgressStatus } from '@/common/enums/common';
import { LANG_CHAIN_SERVICE_OPTIONS } from 'src/constants/configs/config';
import { LangChainService } from 'src/lang_chain/lang_chain.service';
import { LruCacheService } from 'src/lru_cache/lru_cache.service';

@Injectable()
export class VouchersService {
  private readonly logger = new Logger(VouchersService.name);
  private today = new Date();
  private voucherIdxCounter = 1;

  constructor(
    private readonly cache: LruCacheService<IVoucher>,
    private readonly langChainService: LangChainService,
  ) {
    this.logger.log('VouchersService initialized');
  }

  private returnNotSuccessStatus(errorMessage: ProgressStatus) {
    const hashedKey = this.cache.put(errorMessage, errorMessage, null);
    return {
      id: hashedKey,
      status: errorMessage,
    };
  }

  public generateVoucherFromInvoices(invoices: IInvoiceWithPaymentMethod[]): {
    id: string;
    status: ProgressStatus;
  } {
    // Info Murky (20240512) if no invoice, return invalid
    if (
      !invoices ||
      invoices.length === 0 ||
      !invoices.every((invoice) => isIInvoiceWithPaymentMethod(invoice))
    ) {
      return this.returnNotSuccessStatus(ProgressStatus.InvalidInput);
    }

    const invoiceString = JSON.stringify(invoices);
    const hashedKey = this.cache.hashId(invoiceString);
    if (this.cache.get(hashedKey).value) {
      return {
        id: hashedKey,
        status: ProgressStatus.AlreadyUpload,
      };
    }

    // Info Murky (20240423) this is async function, but we don't await
    // it will be processed in background
    this.cache.put(hashedKey, ProgressStatus.InProgress, null);
    this.invoicesToAccountVoucherData(hashedKey, invoices);
    return {
      id: hashedKey,
      status: ProgressStatus.InProgress,
    };
  }

  public getVoucherAnalyzingStatus(resultId: string): ProgressStatus {
    const result = this.cache.get(resultId);
    if (!result) {
      return ProgressStatus.NotFound;
    }

    return result.status;
  }

  public getVoucherAnalyzingResult(resultId: string): IVoucher | null {
    const result = this.cache.get(resultId);
    if (!result) {
      return null;
    }

    if (result.status !== ProgressStatus.Success) {
      return null;
    }

    return result.value;
  }

  private async invoicesToAccountVoucherData(
    hashedId: string,
    invoices: IInvoiceWithPaymentMethod[],
  ): Promise<void> {
    try {
      const invoiceString = JSON.stringify(invoices);
      const metadatas: IVoucherMetaData[] = invoices.map((invoice) => {
        return {
          date: invoice.date,
          voucherType: eventTypeToVoucherType[invoice.eventType],
          companyId: invoice.venderOrSupplyer,
          companyName: invoice.venderOrSupplyer,
          description: invoice.description,
          reason: invoice.paymentReason,
          projectId: invoice.projectId,
          project: invoice.project,
          contractId: invoice.contractId,
          contract: invoice.contract,
          payment: invoice.payment,
        };
      });

      let lineItemsGenerated: ILineItem[];

      try {
        lineItemsGenerated = await this.langChainService.invoke(
          {
            input: invoiceString,
          },
          { recursionLimit: LANG_CHAIN_SERVICE_OPTIONS.recursiveLimit },
        );

        //Depreciate Murky (20240429): debug
        console.log(
          'lineItem output: ',
          JSON.stringify(lineItemsGenerated, null, 2),
        );

        if (!lineItemsGenerated) {
          const errorMessage = 'line items not generated by LLaMA';
          this.logger.error(errorMessage);
          throw new Error(errorMessage);
        }
      } catch (error) {
        this.logger.error(
          `Error in llama genetateResponseLoop in OCR invoicesToAccountVoucherData: ${error}`,
        );
        this.cache.put(hashedId, ProgressStatus.LlmError, null);
        return;
      }

      if (this.today.getDate() !== new Date().getDate()) {
        this.today = new Date();
      }

      try {
        lineItemsGenerated = lineItemsGenerated.map((lineItem) => {
          return cleanILineItem(lineItem);
        });
      } catch (error) {
        this.cache.put(hashedId, ProgressStatus.LlmError, null);
        return;
      }
      const voucherGenerated: IVoucher = {
        // Info Murky (20240512) this is not a good way to generate invoiceIndex
        // it should return array
        invoiceIndex: invoices[0].invoiceId,
        voucherIndex: `${this.today.toISOString().slice(0, 10).replace('-', '')}${this.voucherIdxCounter++}`,
        metadatas,
        lineItems: lineItemsGenerated,
      };

      if (voucherGenerated) {
        this.cache.put(hashedId, ProgressStatus.Success, voucherGenerated);
      } else {
        this.cache.put(hashedId, ProgressStatus.NotFound, null);
      }
    } catch (error) {
      this.cache.put(hashedId, ProgressStatus.SystemError, null);
    }
  }
}
